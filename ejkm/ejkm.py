import streamlit as st
import subprocess
import requests
import string
import secrets
import os, re, json, glob, shutil
import time
from datetime import datetime
from streamlit_keycloak import login

########################################
prefix = "https://"
repository = "repository.edison.re.kr"
usern = "CUSTOM_REPOSITORY_ID"              # input id
userp = "CUSTOM_REPOSITORY_PASSWORD"        # input pw
#os.environ["SINGULARITY_DOCKER_USERNAME"]=usern
#os.environ["SINGULARITY_DOCKER_PASSWORD"]=userp
temp_folder_to_uploaded_files = "/app/custom_containers/"
temp_folder_to_scripts = "/app/custom_scripts/"
########################################

AUTH_REALM = "master"
AUTH_CLIENT_ID = "testapi"
AUTH_LOGIN_URL = "https://auth.edison.re.kr/auth"
AUTH_REDIRECT_URL = "https://testapi.edison.re.kr/v1/ejkm-ui/web"
AUTH_LOGOUT_URL = f"https://auth.edison.re.kr/auth/realms/master/protocol/openid-connect/logout?post_logout_redirect_uri={AUTH_REDIRECT_URL}&client_id={AUTH_CLIENT_ID}"


#######################################################################
############################# TITLE ###################################
#######################################################################

st.write("# EDISON Jupyter Kernel Management 👋")
st.code('''
EDISON Jupyter Kernel Management는 Docker Repository (EDISON2-registry, DockerHub)의
특정 컨테이너 내부의 파이썬 커널들을 사용자 Jupyter 연구환경과 손쉽게 연동시켜
시험할 수 있는 서비스입니다. 지금 사용해보세요!

* 컨테이너 이미지 빌드 위치 : {user_home}/.singularity/{image_name}.sif 
''')

with st.sidebar:
    # keycloak LOGIN
    keycloak = login(
        url=AUTH_LOGIN_URL,
        realm=AUTH_REALM,
        client_id=AUTH_CLIENT_ID,
        auto_refresh=False,
         init_options = {
             "checkLoginIframe": False,
         },
        custom_labels = {
            "labelButton": "Sign in",
            "labelLogin": "로그인 하세요!",#"Please sign in to your account.",
            "errorNoPopup": "Unable to open the authentication popup. Allow popups and refresh the page to proceed.",
            "errorPopupClosed": "Authentication popup was closed manually.",
            "errorFatal": "Unable to connect to Keycloak using the current configuration."
        }
    )
    if keycloak.authenticated:
        if 'keycloak' not in st.session_state:
            st.session_state['keycloak'] = keycloak
            st.session_state['authenticated'] = keycloak.authenticated
    else:
        st.stop()
    username = st.session_state['keycloak'].user_info['preferred_username']
    AUTH_LOGOUT_URL += f"&id_token_hint={st.session_state['keycloak'].id_token}"
    st.markdown(f"""
        <div style="
            border: 2px solid #4CAF50;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            background-color: #f4f4f4;
            display: flex;
            justify-content: space-between;
            align-items: center;
            ">
            {username}
            <a target="_self" href="{AUTH_LOGOUT_URL}"  style="
                text-decoration: none;
                color: #4CAF50;
                font-weight: bold;
                float: right;
                ">LOGOUT</a>
        </div>
        """, unsafe_allow_html=True)
###

###############################################################
# from add_kernel.py - generated by Jeongcheol Lee
###############################################################

def getUserID():

    with subprocess.Popen(['whoami'], stdout=subprocess.PIPE) as proc:
        res=proc.stdout.read().decode("utf-8").strip('\n')
        return res

def getUserHomeDir(username):
    return '/home/'+username+'/'
    #return os.path.expanduser('~')    
    
def getsimgLoc(simg_name):
    if "docker://" in simg_name.lower():
        res = autoBuildSingularityImagefromDockerRepository(simg_name) # sandbox will be supported 20230816
    else:
        res = os.path.join(os.getcwd(),simg_name)
    return os.path.abspath(res)

def autoBuildSingularityImagefromDockerRepository(simg_name):
    sif_name=os.path.basename(simg_name)+'.sif'
    command = ['singularity',
               'build',
               sif_name,
               simg_name
              ]
    with subprocess.Popen(command, stdout=subprocess.PIPE) as proc:
        res=proc.stdout.read().decode("utf-8")
    return os.path.join(os.getcwd(),sif_name)

def getkernelDictandgenJSON(args, simgLocAbsolutePath, kpath):
    res = {}
    res.update({"language":"python"})
    singularity_dict=["singularity", "exec","--writable-tmpfs", simgLocAbsolutePath, kpath, "-m", "ipykernel", "-f", "{connection_file}"]    
    ########
    res.update({"argv":singularity_dict})
    res.update({"display_name":args.dname})
    env_dict={}
    if "python" in kpath:
        env_dict.update({"pip":kpath+" -m pip"})
    res.update({"env":env_dict})
    kernelJsonGen(args, res, kpath)

def autogetkernelDicts(args, scanonly):
    simgLocAbsolutePath = getsimgLoc(args.img) #including instant building
    if os.path.exists(simgLocAbsolutePath):
        if args.kpath == 'auto':
            kpath_list = autogetPythonKernels(simgLocAbsolutePath) 
            if len(kpath_list)==0:
                print("error: there is no python kernel in this image. Try another image.")
                exit(-1)
            if scanonly=="yes":
                print(kpath_list)
                exit(-1)
            for each in kpath_list:
                getkernelDictandgenJSON(args, simgLocAbsolutePath, each)
        else:
            getkernelDictandgenJSON(args, simgLocAbsolutePath, args.kpath)
    else:
        print("error: singularity image ("+simgLocAbsolutePath+") not founded.")
        exit(-1)          
        
def kernelJsonGen(args, res_dict, kpath):
    user = getUserID() # kisti
    user_home = getUserHomeDir()
    img_name = os.path.basename(args.img)#"quantum-mobile_20_11_2a"
    kernel_name = kpath.replace("/","_")
    kernelAdding(user_home, img_name, kernel_name, args, kpath, res_dict)

def kernelAdding(user_home, img_name, kernel_name, args, kpath, res_dict):
    #### check 1 local
    locald = os.path.join(user_home, ".local")
    if os.path.exists(locald):
        print("we have .local/")
    else:
        print("mkdir .local/")
        os.mkdir(locald)
    ##### check 2 share
    locald_with_share = os.path.join(locald, "share")
    if os.path.exists(locald_with_share):
        print("we have share/")
    else:
        print("mkdir share/")
        os.mkdir(locald_with_share)
    ##### check 3 jupyter
    locald_with_share_jupyter=os.path.join(locald_with_share,"jupyter")
    if os.path.exists(locald_with_share_jupyter):
        print("we have jupyter/")
    else:
        print("mkdir jupyter/")
        os.mkdir(locald_with_share_jupyter)
    ##### check 4 kernels
    locald_with_share_jupyter_kernels=os.path.join(locald_with_share_jupyter,"kernels")
    if os.path.exists(locald_with_share_jupyter_kernels):
        print("we have kernels/")
    else:
        print("mkdir kernels/")
        os.mkdir(locald_with_share_jupyter_kernels)
    ##### check 5 img_name
    img_name = "CUSTOM__"+img_name
    locald_with_share_jupyter_kernels_imgname = os.path.join(locald_with_share_jupyter_kernels, img_name)
    locald_with_share_jupyter_kernels_imgname_kernelname = locald_with_share_jupyter_kernels_imgname+"__"+kernel_name
    if os.path.exists(locald_with_share_jupyter_kernels_imgname_kernelname):
        print("we have "+img_name+"__"+kernel_name)
    else:
        print("mkdir "+img_name+"__"+kernel_name)
        os.mkdir(locald_with_share_jupyter_kernels_imgname_kernelname)
    #
    file_path = os.path.join(locald_with_share_jupyter_kernels_imgname_kernelname,"kernel.json")
    if args.dname == 'auto':
        res_dict.update({'display_name':os.path.basename(locald_with_share_jupyter_kernels_imgname_kernelname)})
    with open(file_path, 'w', encoding='utf-8') as file:
        json.dump(res_dict, file)
    print("JSON(kernel conf.) has been generated successfully.")
    if "python" in kpath:
        os.system("singularity exec "+getsimgLoc(args.img)+" "+kpath+" -m pip install ipykernel")

def autogetPythonKernels(absolute_singularity_image_filepath):
    ### find python?.? or python?.?? (number) executable paths in the singularity container image
    args='''singularity exec python.sif bash -c'''
    command = ['singularity',
               'exec',
               absolute_singularity_image_filepath,
               'bash',
               '-c',
               "find / ! -type f \( -type d -path '*python[[:digit:]].[[:digit:]]*' -prune \) -executable -name '*python[[:digit:]].[[:digit:]]' -o -name '*python[[:digit:]].[[:digit:]][[:digit:]]' 2>/dev/null | grep bin/",
              ]
    try:
        with subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) as proc:
            res=proc.stdout.read().decode("utf-8")
    except Exception as e:
        return e
    kpath_list=[res for res in res.split('\n') if "/bin/bash" not in res if "warning" not in res if ''!=res]
    ## check pip module
    if len(kpath_list)>0:
        for each_py_kernel in kpath_list:
            check_cmd = ['singularity',
                       'exec',
                       absolute_singularity_image_filepath,
                       each_py_kernel,"-m","pip"
                       ]
            try:
                with subprocess.Popen(check_cmd, stderr=subprocess.PIPE) as proc_check:
                    check_res=proc_check.stderr.read().decode("utf-8")
                if "No module named pip" in check_res:
                    #removal_list.append(each_py_kernel)
                    kpath_list.remove(each_py_kernel)
            except:
                pass
    return kpath_list
        
def removeAllCustomKernels(username):
    dirlist = glob.glob(os.path.join(os.path.join(getUserHomeDir(username),'.local/share/jupyter/kernels/CUSTOM__*')))
    for each in dirlist:
        try:
            shutil.rmtree(each)
        except OSError:
            os.remove(each)
    print("REMOVE CUSTOM kernels successfully.")
    return True

########################################################################
# from deploy.py  - generated by Jeongcheol Lee
########################################################################

def getImagesList(repo, usern, userp, image=None):
    addr = repo+"/v2/_catalog" if image is None else repo+"/v2/"+image+"/tags/list"
    r=requests.get(addr,auth=(usern,userp))
    return r.json()    

########################################################################

def addUser():
    def _update(text):
        with open('/etc/passwd','w',encoding='utf-8') as file:
            file.write(text)    
    with open('/etc/passwd','r') as f:
        tmp = f.read()
    tmplist = tmp.split('\n')
    ids = [x.split(":")[0] for x in tmplist]
    ## add user information
    try:
        uid = str(st.session_state['keycloak'].user_info['uidNumber'])
        gid = str(st.session_state['keycloak'].user_info['gidNumber'])
        uname=str(st.session_state['keycloak'].user_info['preferred_username'])
    except:
        st.error("Admin account cannot be used in this service. Please logout and use different account.")
    #'jclee:x:300010:300000::/home/jclee:/usr/sbin/nologin'
    user_ids = uname+":x:"+uid+":"+gid+"::"+getUserHomeDir(uname)+":/usr/sbin/nologin\n"
    tmplist_comp = [user_ids if x.startswith(uname+':x:') else x for x in tmplist] # /etc/passwd 에 username이 이미 있다면
    if '\n'.join(tmplist)!='\n'.join(tmplist_comp):
        _update('\n'.join(tmplist_comp)) # 로그인된 정보로 교체
    if st.session_state['keycloak'].user_info['preferred_username'] not in ids:#없으면 추가
        _update(tmp+user_ids)

def UI_default():
    if not st.session_state['authenticated']:
        st.error("Login required!")
        st.stop()
    ### 1. user add to use sudo -u {uname} singularity
    #st.write(st.session_state['keycloak'])
    addUser()
    #st.write("user:",os.getuid())
    uname = st.session_state['keycloak'].user_info['preferred_username']
    userhome=getUserHomeDir(uname)
    uid = st.session_state['keycloak'].user_info['uidNumber']
    gid = st.session_state['keycloak'].user_info['gidNumber']
    #        
    dirlist = glob.glob(os.path.join(os.path.join(userhome,'.local/share/jupyter/kernels/CUSTOM__*')))
    cutted_list = [x.split('CUSTOM__')[1] for x in dirlist]
    ###
    tab_list=["커널 보기","커널 추가","커널 삭제"]
    tab1, tab2, tab3= st.tabs(tab_list)
    ######################################################################################
    with tab1:
        if st.button("***REFERSH***"):
            st.rerun()
        st.subheader("연결된 컨테이너 커널 보기", divider='rainbow')
        tmp=[(x.split('___')[0],x.split('___')[1])  for x in cutted_list]
        res = ""
        for each in tmp:
            res+="(container) "+each[0]+" --- (kernel) "+each[1].replace("_","/")+"\n"
        if res=="":
            res = "There are no connection with container kernels, add kernel first!"
        st.code(res)
    ######################################################################################        
    with tab2:
        st.subheader("1. 컨테이너 이미지 선택", divider='rainbow')
        image_name = ""
        repotype=st.radio(
            "Select a docker repository type",
            ["***NEXUS Local Registry (EDISON repo.)***","***Docker Hub***"],
            captions=["https://nexus.edison.re.kr","https://hub.docker.com"]
            )    
        if repotype == "***NEXUS Local Registry (EDISON repo.)***":
            repo_list = []
            os.environ["SINGULARITY_DOCKER_USERNAME"]=usern
            os.environ["SINGULARITY_DOCKER_PASSWORD"]=userp
            try:
                repo_list = getImagesList(prefix+repository, usern, userp)['repositories']
            except Exception as e:
                st.write(e)
            if repo_list != []:
                option = st.selectbox(
                "Select an image from the repository. (title search available)",
                (repo_list),
                )
                if option:
                    tag_list = []
                    try:
                        tag_list = getImagesList(prefix+repository, usern, userp, option)['tags']
                    except Exception as e:
                        st.write(e)
                    if tag_list != []:
                        tag_option = st.selectbox("Select a tag from the image.",
                                    (tag_list)
                                    )
                        if tag_option:
                            image_name = "docker://"+repository+"/"+option+":"+tag_option

        elif repotype == "***Docker Hub***":
            os.environ["SINGULARITY_DOCKER_USERNAME"]=""
            os.environ["SINGULARITY_DOCKER_PASSWORD"]=""
            #
            image_name = st.text_input('Write a docker container name from DockerHub.')
            if "docker://" not in image_name:
                image_name = "docker://"+image_name
        if image_name != "":
            st.write(image_name)
            generated=False
            logs = ""
            image_filename = image_name.replace("docker://","").replace(repository,"").replace("/","_").replace(":","_").strip("_")
            #
            ########### location to sif deploy
            userhome=getUserHomeDir(st.session_state['keycloak'].user_info['preferred_username'])
            locald = os.path.join(userhome, ".singularity/")
            if os.path.exists(locald):
                print("we have .singularity/")
            else:
                print("mkdir .singularity/")
                os.mkdir(locald)
                os.chown(locald, int(uid), int(gid))
            #
            temp_folder_to_uploaded_files = locald
            #
            submitted = st.button("***Pull*** the image into a temporal directory.")
            if submitted:
                # 1. check file exists
                if os.path.exists(temp_folder_to_uploaded_files+image_filename+".sif"):
                    generated=True
                else:
                    logfile = image_filename+".log"
                    if os.path.exists(temp_folder_to_uploaded_files+logfile):
                        os.remove(temp_folder_to_uploaded_files+logfile)
                    file_stdout = open(temp_folder_to_uploaded_files+logfile,'a+')
                    cmd = ['singularity',
                            'build',
                            temp_folder_to_uploaded_files+image_filename+'.sif',
                            image_name]
                    subprocess_pull = subprocess.Popen(cmd, stdout=file_stdout, stderr=subprocess.STDOUT)
                    logs = ""
                    log_area = st.empty()  # Placeholder for text_area update                
                    while True:
                        if os.path.exists(temp_folder_to_uploaded_files+image_filename+".sif"):
                            generated=True
                            file_stdout.close()
                            break
                        else:
                            if os.path.exists(temp_folder_to_uploaded_files+logfile):
                                with open(temp_folder_to_uploaded_files+logfile, 'r') as l:
                                    _logs = l.read()
                                time.sleep(1)
                                if logs != _logs:
                                    logs = _logs
                                    log_area.code(logs)
            if generated:
                st.subheader(image_filename+" is ready to use!")
                simgLocAbsolutePath = temp_folder_to_uploaded_files+image_filename+".sif"
                st.write("   - "+simgLocAbsolutePath)
                st.session_state.simgpath = simgLocAbsolutePath
                try:
                    os.chown(temp_folder_to_uploaded_files+logfile, int(uid), int(gid))
                    os.chown(st.session_state.simgpath, int(uid), int(gid))
                except:
                    pass
        st.subheader("2. 컨테이너 연결하기", divider='rainbow')
        with st.form("CONNECT ALL KERNELS IN THIS CONTAINER"):
            st.write("This will connect all kernels in this container to your jupyter home.")
            submitted = st.form_submit_button("***CONNECT***", type='primary')
            if submitted:
                if 'simgpath' in st.session_state:
                    st.write("Python kernels in ",st.session_state.simgpath)
                    kpath_list = autogetPythonKernels(st.session_state.simgpath) # container가 root권한 폴더내에 있으므로 임시 권한 변경
                    st.code('\n'.join(kpath_list))
                    if len(kpath_list)==0:
                        st.error("There is no python kernel in this image. Try another image.")
                    else:                    
                        cmd = ['sudo','-u',uname, '/opt/conda/bin/python', '/app/webapps/add_kernel.py','--img',st.session_state.simgpath]
                        #sudo -u jclee /opt/conda/bin/python add_kernel.py --img /home/jclee/.singularity_containers/cicd-streamlit-sghan73_latest.sif
                        try:
                            with subprocess.Popen(cmd, stdout=subprocess.PIPE) as proc:
                                res=proc.stdout.read().decode("utf-8")
                            st.write("Kernels are connected to your Jupyter Home. Congrats!")
                            st.code(res)
                        except Exception as e:
                            res = e
                            st.code(res)
                else:
                    st.error("Container(kernels) did not prepated yet.")



    ######################################################################################
    with tab3:
        ### 2. listing current kernels
        st.subheader("개별 커널 삭제", divider='rainbow')
        option = st.selectbox(
                "Select a kernel to disconnect",
                (dirlist),
                )
        st.write(option)
        if option:
            submitted = st.button("***DISCONNECT*** this kernel.")
            if submitted:
                try:
                    shutil.rmtree(option)
                except OSError:
                    os.remove(option)
                st.success("Disconnect kernel finished, successfully.")
                st.rerun()
        ### 3. add kernels
        ### 4. delete kernels
        st.subheader("전체 커널 삭제", divider='rainbow')
        with st.form("DISCONNECT ALL CONTAINER KERNELS"):
            st.code('\n'.join(cutted_list))
            st.write("This will disconnect all of your container kernels to your jupyter home.")
            disconnected = st.form_submit_button("***DISCONNECT ALL***", type='primary')
            if disconnected:
                if len(cutted_list)>0:
                    removeAllCustomKernels(st.session_state['keycloak'].user_info['preferred_username'])
                    st.success("Disconnected!")
                    st.rerun()
                else:
                    st.write("Nothing to do!")
        

UI_default()
#singularity shell --nv -B./:/app -B/home:/home --pwd /app/webapps --env CUDA_VISIBLE_DEVICES=0 general_containers/streamlit_singularity_only_0.1.sif

